constant: ISI-PLANETMt.
in Mt: BaseKB.
isa: IndexedInfoSource IKBConstant.
comment: "PLANET is a scheme for plan representation and reasoning
developed at ISI.".

;The above is a bookkeeping device which will enable us to keep track
;in Cyc of what Cyc concepts map to what PLANET concepts, via
;'synonymousExternalConcept'.  In a few cases in the present file we
;are going to be pushing the envelope on what is covered by synonymity
;(e.g., cases where concepts map to predicates).  Kathy Burns can help
;us determine what to do in cases where flexibility is needed.


constant: PlanningMicrotheory.
in Mt: BaseKB.
isa: MicrotheoryType IKBConstant.
genls: Microtheory
comment: "A collection of microtheories whose instances implement
various forms of planning context.  Important specializations are
#$PlanBackgroundContext, #$PlanSelectionContext, and #$Plan.".


constant: PlanBackgroundContext.
in Mt: BaseKB.
isa: MicrotheoryType IKBConstant.
genls: PlanningMicrotheory.
comment: "Instances are contexts used for reasoning about #$Plans.
More specifically, #$PlanBackgroundContexts are used to store
high-level information aboutresources, constraints, commitments,
initial stateand purpose that are applicable to a certain class or
type of #$Plan, such as military COAs (see
#$COASpecificationMicrotheory).  All #$Plans of the class in question
will be established as specializations of the appropriate
#$PlanBackgroundContext, so that they inherit these assumptions.".
F:
(isa BattlespaceMilitaryMt PlanBackgroundContext).
in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept 
    PlanBackgroundContext ISI-PLANETMt "planning-context").


constant: PlanSelectionContext.
in Mt: BaseKB.
isa: MicrotheoryType IKBConstant.
genls: PlanningMicrotheory.
comment: "Instances are microtheories containing information pertinent
to evaluating a set of competing plans and selecting one that is
optimal with respect to some set of predetermined criteria represented
in the context.".
cyclistNotes: "In addition to the usual resources, constraints,
initial state data and so forth, it is anticipated that
#$PlanSelectionContexts will contain testing criteria specific to
determining which candidate plans (see
#$candidatePlanOfSelectionContext) are achievable or 'complete' in the
context.  See also #$completeInSelectionContext.".
in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept 
   PlanSelectionContext ISI-PLANETMt "planning-problem").

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;It is not yet certain whether or not we are going to need this.

constant: PlanSelectionBackgroundContext.
in Mt: BaseKB.
isa: MicrotheoryType IKBConstant.
genls: PlanSelectionContext.
comment: "A special class of #$PlanSelectionContext.  Each instance is
a #$Microtheory containing a set of initial assumptions pertinent to
evaluating a set of competing plans and selecting one that is
'optimal' with respect to evaluation criteria stored in the context.
It is possible that in certain circumstances involving reasoning with
plans, we will want to refine such assumption sets: such refinements
will be more specific #$PlanSelectionContexts, linked to the original
#$PlanSelectionBackgroundContext by #$planSelectionRefinement.".

in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept
  PlanSelectionBackgroundContext ISI-PLANETMt "planning-problem-context").

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

constant: planSelectionRefinement.
in Mt: BaseKB.
isa: RuleMacroPredicate TransitiveBinaryPredicate
ReflexiveBinaryPredicate PublicConstant MicrotheoryPredicate
DefaultMonotonicPredicate BinaryPredicate.
genlPreds: genlMt.
arg1Isa: PlanSelectionContext.
arg2Isa: PlanSelectionContext.
comment: "(#$alternativePlanInSelection PSC_SPEC PSC_GEN) means that
the #$PlanSelectionContext PSC_SPEC is a more specific
#$PlanSelectionContext than PSC_GEN: that is, it inherits the
assumptions of PSC_GEN and includes additional assumptions. Since this
predicate is a specialization of #$genlMt, it insures inheritance of
the more general #$PlanSelectionContext by the more specific
#$PlanSelectionContext.".
cyclistNotes: "It would of course be possible to simply use #$genlMt.
However, a suspicion exists that the 'refining' assumptions are of a
particular kind, which as of 2/25/99 remains to be elucidated.  If
this is the case, there is a prima facia justification for using a
specialization of genlMt even though this insures total inheritance
across the access link at this time.".
in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept planSelectionRefinement ISI-PLANETMt
"problem-refinement").

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
F:
(relationAllExists 
  planSelectionRefinement PlanSelectionContext PlanSelectionBackgroundContext). 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


constant: refinesPlan.
in Mt: BaseKB.
isa: RuleMacroPredicate TransitiveBinaryPredicate
ReflexiveBinaryPredicate PublicConstant MicrotheoryPredicate
DefaultMonotonicPredicate BinaryPredicate.
genlPreds: genlMt.
arg1Isa: Plan.
arg2Isa: Plan.
comment: "(#$refinesPlan PLANSPEC PLANGEN) means that the assumptive
constraints, commitments, resources, and goals of represented in
PLANSPEC constitute a superset of those represented in PLANGEN.
Accordingly, the predicate has been made a specialization of genlMt to
insure access".

;Right now, the genlMt link in Cyc is totally unselective: (genlMt MT1
;MT2) means that MT1 inherits all the information that MT2 contains or
;inherits.  Admittedly, PLANET, when it talks about a 'consistent
;superset of commitments' probably means that to apply *only* to
;commitments and not to other assumptions which may or may not be
;inherited.  However, there are plans in the works that will enable us
;to limit the scope of inheritance through genlMt links, and at the
;time that functionality comes on line, we will see if the scope of
;refinesPlan can be stopped down accordingly.


constant: candidatePlanningContext.
in Mt: BaseKB.
isa: RuleMacroPredicate TransitiveBinaryPredicate
ReflexiveBinaryPredicate PublicConstant MicrotheoryPredicate.
genlInverse: genlMt.
arg1Isa: PlanningMicrotheory.
arg2Isa: PlanningMicrotheory.
comment: "(#$candidatePlanOfSelectionContext GEN_CONTEXT CONTEXT) means that CONTEXT is a candidate planning context being tested for suitability according to testing criteria established in GEN_CONTEXT.  CONTEXT may be a #$Plan, a #$PlanSelectionContext, or a #$PlanBackgroundContext, and likewise for GEN_CONTEXT; however if GEN_CONTEXT is a #$PlanBackgroundContext, CONTEXT must be a #$PlanSelectionContext, and if GEN_CONTEXT is a #$PlanSelectionContext, then CONTEXT must be a #$Plan.  We don't rule out the case where GEN_CONTEXT is a #$Plan, but we would not ordinarily expect to find such a case.  Since this predicate is a #$genlInverse of #$genlMt, it insures that CONTEXT has mt-access to GEN_CONTEXT."
F: 
(interArgIsa1-2 candidatePlanningContext PlanBackgroundContext
PlanSelectionContext).
F:
(interArgIsa1-2 candidatePlanningContext PlanSelectionContext Plan).

in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept candidatePlanningContext ISI-PLANETMt "candidate").

constant: candidatePlanInSelectionContext.
in Mt: BaseKB.
isa: RuleMacroPredicate TransitiveBinaryPredicate
ReflexiveBinaryPredicate PublicConstant MicrotheoryPredicate
DefaultMonotonicPredicate BinaryPredicate.
genlInverse: genlMt.
genlPreds: candidatePlanningContext.
arg1Isa: PlanSelectionContext.
arg2Isa: Plan.
comment: "(#$candidatePlanInSelectionContext PSC PLAN) means that PLAN
is a candidate #$Plan being tested for suitability according to the
testing criteria asserted in PSC.  Note that since this predicate is a
#$genlInverse of #$genlMt, asserting it of PLAN and PSC insures that
PLAN has access to all of the assumptions PSC has access to.  Some
important specializations include #$consistentInSelectionContext,
#$completeInSelectionContext, #$infeasibleInSelectionContext, etc.
All such predicates thus insure access on the part of the #$Plan to
the assumptions in the #$PlanSelectionContext.".
in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept candidatePlanInSelectionContext ISI-PLANETMt
"candidate-plan").

constant: consistentPlanInSelectionContext.
in Mt: BaseKB.
isa: RuleMacroPredicate TransitiveBinaryPredicate
ReflexiveBinaryPredicate PublicConstant MicrotheoryPredicate
DefaultMonotonicPredicate BinaryPredicate.
genlPreds: candidatePlanInSelectionContext.
arg1Isa: PlanSelectionContext.
arg2Isa: Plan.
comment: "(#$consistentPlanInSelectionContext PSC PLAN) means that the
assumptive commitments of PLAN are consistent with one another, with
the assumptions of the #$PlanSelectionContext PSC, and with the
assumptions of the larger #$PlanBackgroundContext to which PSC has
access.".
in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept consistentPlanInSelectionContext ISI-PLANETMt
"Consistent-plan")

in Mt: BaseKB:
F:
(implies
  (and
    (candidatePlanInSelectionContext ?PSC ?PLAN)     
    (implies
      (ist ?PLAN ?PROP)
      (ist ?PSC (consistent ?PROP))))
  (consistentPlanInSelectionContext ?PSC ?PLAN)).
;Support for the above rule is currently very limited, although our
;new recursive ask capability may not put a weak form of consistency
;checking outside our reach.  However, in the grander scheme of
;things, it's important to realize that support *can* only remain
;imperfect, or first-order predicate calculus would not be
;semi-decideable.  Basically we want to say that if
;(candidatePlanInSelectionContext PSC PLAN) and everything that is
;derivable in PLAN is provably consistent with PSC, then
;(consistentPlanInSelectionContext ?PSC ?PLAN).  But 'provably consistent'
;can only ever mean 'unable to prove inconsistent' for an inference
;engine, and so the limiting factor will always be the performance of
;the Cyc inferrer and its HL modules.


constant: feasiblePlanInSelectionContext.
in Mt: BaseKB.
isa: RuleMacroPredicate TransitiveBinaryPredicate
ReflexiveBinaryPredicate PublicConstant MicrotheoryPredicate
DefaultMonotonicPredicate BinaryPredicate.
genlPreds: candidatePlanInSelectionContext.
arg1Isa: PlanSelectionContext.
arg2Isa: Plan.
comment: "(#$feasiblePlanInSelectionContext PSC PLAN) means that there
exists a COMPPLAN such that (#$refinesPlan COMPPLAN FEASPLAN) and
(#$completePlanInSelectionContext PSC COMPPLAN).  Thus, there exists a
plan whose assumptions constitute a superset of the assumptions of
PLAN that contains the necessary commitments to achieve its
goals. Also, if there is any plan in the PSC such that
(#$completePlanInSelectionContext PSC PLAN), any plan of which PLAN is a
refinement is said to be #$feasiblePlanInSelectionContext with respect to
PSC. Ordinarily #$feasiblePlanInSelectionContext entails
#$consistentPlanInSelectionContext, hence the #$genlPreds relation.".
in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept feasiblePlanInSelectionContext ISI-PLANETMt
"feasible-candidate-plan").

constant: completePlanInSelectionContext.
in Mt: BaseKB.
isa: RuleMacroPredicate TransitiveBinaryPredicate
ReflexiveBinaryPredicate PublicConstant MicrotheoryPredicate
DefaultMonotonicPredicate BinaryPredicate.
genlPreds: feasiblePlanInSelectionContext.
arg1Isa: PlanSelectionContext.
arg2Isa: Plan.
comment: "(#$completePlanInSelectionContext PSC PLAN) means that PLAN
includes the tasks necessary to achieve its goals according to a
testing criterion specified in PSC .  Any planFEASPLAN such that
(refinesPlan PLAN FEASPLAN) is true in the PSC (i.e., such that the
assumptive constraints of PLAN constitute a proper superset of the
assumptive constraints of FEASPLAN) is #$feasiblePlanInSelectionContext.
Note that if a plan is #$completePlanInSelectionContext it is itself
#$feasiblePlanInSelectionContext, hence the genlPreds relation.".
cyclistNotes: "What relationship #$completePlanInSelectionContext and
#$consistentPlanInSelectionContext bear to the formal concepts of
'consistency' and 'completeness' has yet to be fully elucidated.".
;see also comment on rule for consistentPlanInSelectionContext.
in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept completePlanInSelectionContext ISI-PLANETMt
"Complete-plan").
in Mt: BaseKB.
F:
(implies
   (and
     (completePlanInSelectionContext ?PSC ?PLANCOMPLETE)
     (refinesPlan ?PLANCOMPLETE ?PLANFEASIBLE))
   (feasiblePlanInSelectionContext ?PSC ?PLAN)).

F:
(implies
  (feasiblePlanInSelectionContext ?PSC ?PLAN)
  (thereExists ?REFINEMENT
    (and
      (refinesPlan ?REFINEMENT ?PLAN)
      (completePlanInSelectionContext ?PSC ?PLAN)))).



constant: inFeasiblePlanInSelectionContext.
in Mt: BaseKB.
isa: RuleMacroPredicate TransitiveBinaryPredicate
ReflexiveBinaryPredicate PublicConstant MicrotheoryPredicate
DefaultMonotonicPredicate BinaryPredicate.
genlPreds: candidatePlanInSelectionContext.
negationPreds: feasiblePlanInSelectionContext.
arg1Isa: PlanSelectionContext.
arg2Isa: Plan.
comment: "(#$inFeasiblePlanInSelectionContext PSC PLAN) means that there
does not exist a REFINEMENT such that (refinesPlan REFINEMENT PLAN)
and such that REFINEMENT can achieve its goals according to the
criteria established in PSC.  Note that
(#$infeasiblePlanInSelectionContext PSC PLAN) does not imply
(#$rejectedPlanInSelectionContext PSC PLAN) (although the converse is
true) because some relaxation of the PSC constraints on PLAN may be
applied.".
in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept inFeasiblePlanInSelectionContext ISI-PLANETMt 
"unfeasible-candidate-plan").

constant: justifiedPlanInSelectionContext.
in Mt: BaseKB.
isa: RuleMacroPredicate TransitiveBinaryPredicate
ReflexiveBinaryPredicate PublicConstant MicrotheoryPredicate
DefaultMonotonicPredicate BinaryPredicate.
genlPreds: completePlanInSelectionContext.
arg1Isa: PlanSelectionContext.
arg2Isa: Plan.
comment: "(#$justifiedPlanInSelectionContext PSC PLAN) means that PLAN can
accomplish its goals using some minimal set of commitments as
specified in the PSC.  #$justifiedPlanInSelectionContext entails
#$completePlanInSelectionContext, hence the #$genlPreds relation.".
in Mt: ISI-PLANETMt.
>F:
(synonymousExternalConcept justifiedPlanInSelectionContext ISI-PLANETMt 
"Justified-plan").


;All of the foregoing seem to be well-founded Cyc predicates insofar
;as there would be no concern about writing rules in a PSC, say that
;concluded to GAFs involving them.  As regards the predicates in the
;following ;;;; block, however, there is some question as to how they
;would function internal to CycL.  This concern, incidentally, is very
;similar to the point Cleo has already made concerning the
;'evaluation' vocabulary.  All are, in effect, descriptors for some
;internal or external inference process envisaged as currently going
;on.

;Note that the extensions of all three predicates would change over
;the course of the run time of any plan evaluation, refinement, and/or
;generation scheme.  This does not preclude their usefulness, I hasten
;to add: however, certainly untriedPlanInSelectionContext, and possibly
;rejectPlanInSelectionContext and selectPlanInSelectionContext, seem to imply
;a situation where assertions would be continuously asserted and
;unasserted in Cyc over the course of the performance of some
;critiquing engine with which the Cyc system was interacting.

;I have changed the names of selectPlanInSelectionContext and
;rejectPlanInSelectionContext from 'participle' to 'imperative' because of
;the prospect they seem to afford of actually writing instructions for
;various critiquing engines in CycL, e.g.--

;F:
;(implies
;  (justifiedPlanInSelectionContext ?PSC ?PLAN)
;  (selectPlanInSelectionContext ?PSC ?PLAN)).


;If this is deemed desireable, we may want to add a third arg to these
;to specify the critiquing engine for whom the instruction is being
;written.  All of this, I hardly need add, is highly speculative.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

constant: untriedPlanInSelectionContext.
in Mt: BaseKB.
isa: RuleMacroPredicate TransitiveBinaryPredicate
ReflexiveBinaryPredicate PublicConstant MicrotheoryPredicate
DefaultMonotonicPredicate BinaryPredicate.
genlPreds: candidatePlanInSelectionContext.
arg1Isa: PlanSelectionContext.
arg2Isa: Plan.
comment: "(#$untriedPlanInSelectionContext PSC PLAN) means that in the
context of the assertion, PLAN has not been evaluated according to the
testing criteria specified in PSC.".
in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept untriedPlanInSelectionContext ISI-PLANETMt
"untried-candidate-plan")

constant: selectPlanInSelectionContext.
in Mt: BaseKB.
isa: RuleMacroPredicate TransitiveBinaryPredicate
ReflexiveBinaryPredicate PublicConstant MicrotheoryPredicate
DefaultMonotonicPredicate BinaryPredicate.
genlPreds: candidatePlanInSelectionContext.
arg1Isa: PlanSelectionContext.
arg2Isa: Plan.
comment: "(#$selectedPlanInSelectionContext PSC PLAN) means that in the
context of the assertion, PLAN should be selected according
to the testing criteria stored in the #$PlanSelectionContext
PSC. Usually, but not always, this will result from a plan's being
concluded to be #$justifiedInPlanSelectionContext, or more weakly,
#$completePlanInSelectionContext.".
in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept selectPlanInSelectionContext ISI-PLANETMt
"selected-candidate-plan").

constant: rejectPlanInSelectionContext.
in Mt: BaseKB.
isa: RuleMacroPredicate TransitiveBinaryPredicate
ReflexiveBinaryPredicate PublicConstant MicrotheoryPredicate
DefaultMonotonicPredicate BinaryPredicate.
genlPreds: infeasiblePlanInSelectionContext.
arg1Isa: PlanSelectionContext.
arg2Isa: Plan.
comment: "(#$rejectPlanInSelectionContext PSC PLAN) means that in the context of the assertion, PLAN should be rejected according
to the testing criteria stored in the #$PlanSelectionContext PSC. "
in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept rejectPlanInSelectionContext ISI-PLANETMt
"rejected-candidate-plan")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
F:
(genls Plan PlanningContext).

in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept Plan ISI-PLANETMt "plan").
F:
(synonymousExternalConcept PurposefulAction ISI-PLANETMt "plan-task").
F:
(synonymousExternalConcept Goal ISI-PLANETMt "goal-specification").
F:
(synonymousExternalConcept subEvents ISI-PLANETMt "sub-task").
F:
(synonymousExternalConcept preconditionFor-PropSit ISI-PLANETMt "preconditions").
F:
(synonymousExternalConcept ScriptType ISI-PLANETMt "plan-task-template")

constant: planningAgent.
in Mt: BaseKB.
isa: BinaryPredicate IKBConstant.
arg1Isa: PlanningMicrotheory.
arg2Isa: Agent. 
comment: "(#$planningAgent PLAN AGENT) means that AGENT is the AGENT
is an AGENT directly responsible for devising and using the planning
context PLAN, and that AGENT has a direct stake and interest in a
successful execution of PLAN.".

constant: executionOfPlan.
in Mt: BaseKB. 
isa: BinaryPredicate PublicConstant.
arg1Isa: Plan.
arg2Isa: PurposefulAction.
comment: "(executionOfPlan PLAN EVENT) means that EVENT is a complex
#$Event, generally an instance of an instance of #$ScriptType, that
figures as an execution of the #$Plan represented by PLAN.  EVENT may
be reified within the #$Microtheory PLAN itself, or it may be in a
higher-order mt to which PLAN has access.".
cyclistNotes: "This predicate is used for linking instances of #$Plan
with complex temporal objects about which temporal assertions can be
made.  This enables us to state the temporal presuppositions of
predicates that reference plans in their argument structures.".


F:
(genlPreds operationOfCOA executionOfPlan).

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;planning context restrictions

constant: PlanContextRestrictionPredicate.
in Mt: BaseKB.
isa: IKBConstant PredicateCategory.
genls: Predicate.
comment: "A #$PlanContextRestrictionPredicate can be any relation
on a plan, planning problem, context or task that constrains the forms
of refinements of instantiations possible.".
in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept 
    PlanContextRestrictionPredicate ISI-PLANETMt "plan-restriction").

constant: PlanContextConstraintPredicate.
in Mt: BaseKB.
isa: IKBConstant PredicateCategory.
genls: PlanContextRestrictionPredicate.
disjointWith: PCCommitmentPredicate.
comment: "Plan constraints are 'external' restrictions that are part
of the problem definition of a planning context.  As such they are
usually expressed in 'higher level' instances of
#$PlanBackgroundContext and #$PlanSelectionContext.  Instances of
#$PlanContextConstraintPredicate help in expressing such constraints.  They are
generally 'type level' and apply to more than one plan.".
in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept PlanContextConstraintPredicate ISI-PLANETMt "constraints").

constant: PlanContextCommitmentPredicate.
in Mt: BaseKB.
genls: PlanContextRestrictionPredicate.
in Mt: ISI-PLANETMt.
comment: "Plan commitments are restrictions added by the planning
agent to denote choices made during search.  They are more 'low level'
than plan constraints, and are generally represented directly within
the context of the #$Plan itself.  Instances of
#$PlanContextCommitmentPredicate are used for keeping track of the commitments
within a #$Plan, and also for writing rules that apply to such commitments.".
F:
(synonymousExternalConcept PlanContextCommitmentPredicate ISI-PLANETMt "commitments").


constant: orderingRestrictionInPlanContext.
in Mt: BaseKB.
isa: IKBConstant QuaternaryPredicate PlanContextConstraintPredicate.
arg1Isa: PlanningContext.
arg2Isa: ScriptType.
arg2Genl: PurposefulAction.
arg3Isa: ScriptType.
arg3Genl: PurposefulAction.
arg4Isa: ComplexTemporalRelation.
comment: "(orderingRestrictionInPlanContext CONTEXT EVENT_TYPE1 EVENT_TYPE2
TEMPPRED)means that one of the assumptive constraints of the
#$PlanningContext CONTEXT is that, in any plan inheriting the
assumptions of CONTEXT, there must be an event of type EVENT_TYPE1
bearing the #$ComplexTemporalRelation TEMPPRED to some event of
EVENT_TYPE2.".
in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept 
  orderingRestrictionInPlanContext ISI-PLANETMt "ordering-restriction")
in Mt: BaseKB.
F:
(implies 
  (and
   (isa ?PC PlanningContext)
   (isa ?PLAN Plan)
   (planningAgent ?PLAN ?AGENT)
   (executionOfPlan ?PLAN ?EXEC)
   (genlMt ?PLAN ?PC)
   (orderingRestrictionInPlanContext ?PC ?EVENT_TYPE1 ?EVENT_TYPE2 ?TEMPPRED))
  (preconditionFor-Props
    (thereExists ?EVENT_1
      (thereExists ?EVENT_2
        (and
          (subEvents ?EXEC ?EVENT1)
          (subEvents ?EXEC ?EVENT2)
          (isa ?EVENT_1 ?EVENT_TYPE1)
          (isa ?EVENT_2 ?EVENT_TYPE2)
          (?TEMPRED ?EVENT_TYPE1 ?EVENT_TYPE2))))
    (successfulForAgents ?EXEC ?AGENT))).
;I am beginning to think that we need a successfulForAgents variant for Plans.

constant: commitmentOfPlan.
in Mt: BaseKB.
isa: BinaryPredicate IKBConstant PlanContextCommitmentPredicate.
arg1Isa: PlanningMicrotheory.
arg2Isa: Situation.
comment: "(#$commitmentOfPlan PLAN SITUATION) means that the reified
#$Situation SITUATION in the context of PLAN counts as a 'commitment'
made by the #$planningAgent to figure as a definite step in the
#$executionOfPlan.  See #$planningAgent, #$executionOfPlan, and
#$PlanContextCommitmentPredicate.".
in Mt: ISI-PLANETMt.
(synonymousExternalConcept eventOfPlan ISI-PLANETMt "plan-commitment")

constant: eventOfPlan.
in Mt: BaseKB.
isa: BinaryPredicate IKBConstant PlanContextCommitmentPredicate.
genlPreds: commitmentOfPlan.
arg1Isa: PurposefulAction.
arg2Isa: PlanningMicrotheory.
comment: "(eventOfPlan EVENT PLANMT) means that EVENT is a
hypothetical Event referenced in the description of a plan that is
represented in the Plan microtheory PLANMT. Ordinarily, such an
assertion will be made within PLANMT itself, and every event in the
plan that figures as a 'planned' event will have such an assertion
made of it.".
in Mt: ISI-PLANETMt.
(synonymousExternalConcept eventOfPlan ISI-PLANETMt "task-of")

constant: intentInPlan.
in Mt: BaseKB.
isa: TernaryPredicate IKBConstant PlanContextConstraintPredicate.
arg1Isa: Agent.
arg2Isa: PlanningMicrotheory.
arg3Isa: Goal.
comment: "(#$intentInPlan AGENT PLAN GOAL) means that one of the
purposes which AGENT intends for the #$PlanningMicrtotheory PLAN to
accomplish is GOAL.  This predicate is the plan-analog of
#$purposeInEvent.".
cyclistNotes: "The constraint on the second argument is
#$PlanningMicrotheory, so this predicate can be used to specify the
purpose of the #$planningAgent for planning contexts that are broader
than mere #$Plans: i.e., #$PlanBackGroundContexts and
#$PlanSelectionContexts.".

in Mt: ISI-PLANETMt.
(synonymousExternalConcept intentInPlan ISI-PLANETMt "accomplishes")
;This is a little different from the ISI 'accomplishes' and we may
;want to discuss this.  In Cyc, I think we'd like simply to map from
;the #$planningAgent and the plan to the #$Goal.  It's very much
;analogous to the extant Cyc predicate #$purposeInEvent.
 
in Mt: BaseKB.
F:
(requiredArg2Pred Plan intentInPlan). 
F:
(implies
  (intentInPlan ?AGENT ?PLAN ?GOAL)
  (planningAgent ?PLAN ?AGENT)).


constant: purposeOfPlan.
in Mt: BaseKB.
isa: BinaryPredicate IKBConstant PlanContextConstraintPredicate.
arg1Isa: Plan.
arg2Isa: Goal.
comment: "(#$purposeOfPlan PLAN GOAL) means that in a higher-level
instance of #$PlanBackgroundContext or #$PlanSelectionContext, the
purpose of the #$Plan PLAN is GOAL. What this implies will vary from
context to context: however there will often be the entailment that
#$Agents in the context who are tasked with carrying out PLAN will
themselves have GOAL as a #$goals. For the present, we remain agnostic
as to how a #$Plan may inherit a 'purpose', apart from stipulating
that (#$intentInPlan AGENT PLAN GOAL) implies (#$purposeOfPlan PLAN
GOAL). However, it seems fairly certain that (#$purposeOfPlan PLAN
GOAL) implies that there is an #$Agent either developing or executing
PLAN who has GOAL as a purpose.".

F:
(implies
  (and
    (isa ?PLAN Plan)
    (intentInPlan ?AGENT ?PLAN ?GOAL))
  (purposeOfPlan ?PLAN ?GOAL)).

in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept purposeOfPlan ISI-PLANETMt "plan-goal").

;Note--any and all propositional purposeSpecificationPreds for plans
;should have purposeOfPlan as the genlPreds.  propositional
;purposeSpecificationPreds for events should have purposeOfEvent as
;the genlPreds.  propositional successCriteria preds for plans should
;have constraintOfPlan as the genlPreds; propositional success
;criteria preds for events should have constraintOfEvent as the
;genlPreds.

constant: planSelectionGoal.
in Mt: BaseKB.
isa: BinaryPredicate IKBConstant PlanContextConstraintPredicate.
arg1Isa: PlanSelectionContext.
arg2Isa: Goal.

F:
(implies
    (and
      (isa ?PLAN PlanSelectionContext)
      (intentOfPlan ?AGENT ?PLAN ?GOAL))
    (planSelectionGoal ?PLAN ?GOAL)).

in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept planSelectionGoal ISI-PLANETMt "problem-goal"). 
   
constant: timeConstraintOfPlan.
in Mt: BaseKB.
isa: PlanContextConstraintPredicate IKBConstant BinaryPredicate.
arg1Isa: Plan.
arg2Isa: TimeQuantity.  
comment: "(#$timeConstraintOfPlan PLAN DURATION) means that ".


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Restrictions on Tasks

constant: PlanActionRestrictionPredicate.
in Mt: BaseKB.
isa: PredicateCategory PublicConstant.
genls: Predicate.
comment: "A collection of predicates.  Instances are used to express
durationalconstraints, constraints relating to temporal ordering, and
subeventual commitments relating to reified #$PurposefulActions in
#$Plans.".

constant: timeConstraintOfAction.
in Mt: BaseKB.
isa: BinaryPredicate PlanActionRestrictionPredicate PublicConstant.
arg1Isa: PurposefulAction.
arg2Isa: Duration.
comment: "(#$timeConstraintOfAction ACT DUR) means that in the
planning context of the assertion, ACT should take no longer than the
#$Time-Quantity DUR.".
in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept
   timeConstraintOfAction ISI-PLANETMt "temporal-constraints")
F:
(implies
   (timeConstraintOfAction ?ACT ?DUR)
   (preconditionFor-PropSit
     (measure ?ACT ?DUR) ?ACT)).



constant: commitmentOfPlanAction.
in Mt: BaseKB.
isa: BinaryPredicate PlanActionRestrictionPredicate PublicConstant.
genlPreds: temporallySubsumes.
arg1Isa: PurposefulAction.
arg2Isa: Situation-Temporal.
comment: "(#$commitmentOfPlanAction ACT SIT) means that the
#$planningAgent who is committing to ACT is also committing to the
#$Situation-Temporal SIT, which ACT temporally subsumes.".
F:
(implies
  (and
    (commitmentOfPlanAction ?ACT ?SIT)
    (commitmentOfPlan ?PLAN ?ACT))
  (commitmentOfPlan ?PLAN ?SIT)).


in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept commitmentOfPlanAction ISI-PLANETMt "task-commitments").

constant: subEventsOfPlanAction.
in Mt: BaseKB.
isa: BinaryPredicate PlanActionRestrictionPredicate PublicConstant.
genlPreds: subEvents commitmentOfPlanAction.
arg1Isa: PurposefulAction.
arg2Isa: Event.
in Mt: ISI-PLANETMt.
comment: "(#$subEventsOfPlanAction ACT EVENT) means that the
#$planningAgent for whom ACT is a commitment also has ACT's
#$subEvents EVENT as a commitment.".
cyclistNotes: "This predicate is a specialization of #$subEvents.  It
should be used to indicate that a particular refied subevent of a
reified action-commitment in a #$Plan is not only a subevents, but
also a commitment of the #$planningAgent developing the #$Plan.".

F:
(implies
  (and
    (subEventsOfPlanAction ?ACT ?EVENT)
    (eventOfPlan ?PLAN ?ACT))
  (eventOfPlan ?PLAN ?EVENT)).



;-------------------------------------------------------------------------
;The Parallels So Far--

;      EVENTS                                          PLANS

;PlanActionRestrictionPredicate            PlanContextRestrictionPredicate  
;-                                         PlanContextCommitmentPredicate       -                                         PlanContextConstraintPredicate      

;If we go with the 'high-level'/'low-level' distinction between
;'constraint' and 'commitment', there is no corresponding distinction
;between commitment and constraint for actions as there is for planning
;contexts.  This is because reified actions in #$Plans already have the
;status of 'commitments': thus, subEvents that are restrictions will
;have the status of 'commitments', too.  Ordering restrictions can
;either be expressed as constraints in a higher level planning context,
;using orderingRestrictionInPlanContext, or by using
;ComplexTemporalRelations to order events in Plans themselves.
;Durational constraints, using the predicate timeConstraintOfAction,
;can be expressed either using rules in higher level planning contexts,
;or GAFs in Plans.


;commitmentOfPlanAction                    commitmentOfPlan
;subEventsOfPlanAction                     eventOfPlan
;purposeInEvent                            intentInPlan
;purposeOfEvent                            purposeOfPlan

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;RESOURCES

constant: resourceInEvent.
in Mt: BaseKB.
isa: ActorSlot IKBConstant.
arg1Isa: PurposefulAction.
arg2Isa: SomethingExisting.
comment: "(#$resourceInEvent EVENT RESOURCE) means that, in any #$Plan
in which the assertion holds, if AGENT is to be the performedBy in
EVENT (i.e., if (performedBy EVENT AGENT) is asserted in PLAN), then
it is a precondition for EVENT being #$successfulForAgents that AGENT #$controls RESOURCE. The
precise meaning of #$controls will vary depending upon the thing
playing the role of 'resource' in the context.".
cyclistNotes: "There is a weaker sense in which a #$SomethingExisting
can play the role of 'resource' in an action or a plan: namely, the
situation can be such that if the agent who is executing the plan or
the action controls the resource, the plan or action can be executed
more efficiently than it could be otherwise, with efficiency being
cashed out in terms of some weaker success criterion.".

F:
(implies
  (and 
    (resourceInEvent ?EVENT ?RESOURCE)
    (performedBy ?EVENT ?AGENT))
  (preconditionFor-Props 
      (controls ?AGENT ?RESOURCE) (successfulForAgents ?EVENT ?AGENT))).

in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept resourceInEvent ISI-PLANETMt "resource").


;For critiquing purposes, using the salient rule would probably entail
;making unitAssignedToTask a spec-pred of performedBy, a step I have
;been a little reluctant to take, albeit it is the natural
;interpretation given the 'deontic' character of the planning context:
;'to be performedBy'==>'performedBy' in a SupposedToBeMicrotheory.
;However, it isn't clear we actually need to bank on such a rule for
;critiquing purposes.


constant: resourceInPlan.
in Mt: BaseKB.
isa: Role IKBConstant BinaryPredicate.
arg1Isa: PlanningMicrotheory.
arg2Isa: SomethingExisting.
comment: "(#$resourceInPlan PLAN RESOURCE) means that if EXEC is an
execution of PLAN performedBy AGENT, then (#$controls AGENT RESOURCE)
is a precondition for EXEC being #$successfulForAgents.  Exactly what
#$controls will entail will vary from context to context."
cyclistNotes: "There is a weaker sense in which a #$SomethingExisting
can play the role of 'resource' in an action or a plan: namely, the
situation can be such that if the agent who is executing the plan or
the action controls the resource, the plan or action can be executed
more efficiently than it could be otherwise, with efficiency being
cashed out in terms of some weaker success criterion.".


F:
(implies
  (and 
    (isa ?PLAN Plan)
    (executionOfPlan ?PLAN ?EXEC)
    (performedBy ?EXEC ?AGENT)
    (resourceInPlan ?PLAN ?RESOURCE))
  (preconditionFor-Props
     (controls ?AGENT ?RESOURCE)
     (successfulForAgents ?EXEC ?AGENT))).

in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept resourceInPlan ISI-PLANETMt "planning-resource")


constant: actionResourceQuantForTime.
in Mt: BaseKB.
isa: QuaternaryPredicate Role IKBConstant.
arg1Isa: PurposefulAction.
arg2Isa: SpatialThing-Localized.
arg3Isa: Volume.
arg4Isa: TemporalThing.
comment: "(#$actionResourceQuantForTime ACT THING QUANT TEMP) means
that in ACT, a quantity QUANT of THING is a required resource for the
duration of TEMP, in the sense that the agent performing ACT must have
'access' to a QUANT amount of THING for TEMP in order for ACT to be
#$successfulForAgents.".
F:
(interArgReln1-4 actionResourceQuantForTime temporalBoundsContain).

>F:
(implies
  (and
    (actionResourceQuantForTime ?ACT ?THING ?QUANT ?TEMP)
    (volumeOfObject ?THING ?VOL))
  (preconditionFor-PropSit
    (greaterThanOrEqualTo ?VOL ?QUANT) ?ACT)).

F:
(implies
  (and
    (actionResourceQuantForTime ?ACT ?THING ?QUANT ?TEMP)
    (performedBy ?ACT ?AGENT))
  (preconditionFor-Props
    (thereExists ?PART
      (and
        (physicalDecompositions ?THING ?PART)
        (volumeOfObject ?PART ?QUANT)
        (holdsIn ?TEMP (controls ?AGENT ?PART))))
    (successfulForAgents ?ACT ?AGENT))).

in Mt: ISI-PLANETMt.
F:
(synonymousExternalConcept
   actionResourceQuantForTime ISI-PLANETMt "resource-requirement").


constant: planResourceQuantForTime.
in Mt: BaseKB.
isa: QuaternaryPredicate PublicConstant.
arg1Isa: PlanningMicrotheory.
arg2Isa: ExistingStuffType.
arg2Genl: SpatialThing-Localized.
arg3Isa: Volume.
arg4Isa: TemporalObjectType.
arg4Genl: Event.
constant: "(#$planResourceQuantForTime PLAN STUFFTYPE QUANT TEMPTYPE)
means that in an execution of PLAN the executing agent needs to have
control of quantity QUANT of some stuff ot type STUFFTYPE for the
duration of an event of type TEMPTYPE in the plan exectution, in order for
the execution to be #$successfulForAgents.".
cyclistNotes

F:
(implies
  (and
    (planResourceQuantForTime ?PLAN ?THINGTYPE ?QUANT ?TEMPTYPE)
    (executionOfPlan ?PLAN ?EXEC)
    (performedBy ?EXEC ?AGENT))
  (preconditionFor-Props
     (thereExists ?TEMP
       (thereExists ?THING
        (thereExists ?PART
          (and
            (isa ?THING ?THINGTYPE)
            (isa ?TEMP ?TEMPTYPE)
            (subEvents ?EXEC ?TEMP)
            (greaterThanOrEqualTo
               (FunctionValueFn (FunctionToArg 2 volumeOfObject) ?THING)
               ?QUANT)
            (physicalDecompositions ?THING ?PART)
            (volumeOfObject ?PART ?QUANT)
            (holdsIn ?TEMP (controls ?AGENT ?PART)))))))).


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; for our purposes we probably want to separate out cases where agents
; are regarded as 'resources' in some planning event, since this seems
; substantially different from cases where we deal with 'inanimate' resources.

constant: agentResourceInEvent.
in Mt: BaseKB.
isa: ActorSlot IKBConstant.
arg1Isa: PurposefulAction.
arg2Isa: Agent.
conceptuallyRelated: resourceInEvent.
comment: "(#$agentResourceInEvent ACT AGENT) means that for ACT to be
#$successfulForAgents for any performing agent, it must be the case
that AGENT is #$behaviorCapable of playing the role of
#$assistingAgent in any specialization of #$Event of whish ACT is an
instance.".

F:
(implies
  (and
    (agentResourceInEvent ?EVENT ?AGENT)
    (performedBy ?EVENT ?PERFORMER)
    (isa ?EVENT ?EVENTTYPE)
    (genls ?EVENTTYPE Event))
  (preconditionFor-Props
     (behaviorCapable ?AGENT ?EVENTTYPE assistingAgent) 
     (successfulForAgents ?EVENT ?PERFORMER))).

;Again, it isn't altogether clear that we need this rule for purposes
;of critique: e.g., we may simply want to ask whether the identified
;agentResourceInEvent is behaviorCapable of being assistingAgent in
;the salient event-type, although how we pick out saliency becomes an
;interesting question.

constant: agentResourceInPlan.
in Mt: BaseKB.
isa: ActorSlot IKBConstant.
arg1Isa: PlanningMicrotheory.
arg2Isa: Agent.
conceptuallyRelated: resourceInPlan.
comment: "(#$agentResourceInPlan PLAN AGENT) means that if EXEC is an
execution of PLAN, and is #$performedBy PERFORMER, then AGENT's being
#$behaviorCapable of being the #$assistingAgent in any specialization
of #$Event of which EXEC isan instance is a precondition for EXEC
being #$successfulForAgents.".

F:
(implies
 (and
  (agentResourceInPlan ?PLAN ?AGENT)
  (executionOfPlan ?PLAN ?EXEC)
  (isa ?EXEC ?EVENTTYPE)
  (performedBy ?EXEC ?PERFORMER)
  (genls ?EVENTTYPE Event))
 (preconditionFor-Props 
   (behaviorCapable ?AGENT ?EVENTTYPE assistingAgent)
   (successfulForAgents ?EVENT ?PERFORMER))).
  


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Military Task-Specific Constraints

constant: depthConstraintOfTask.
in Mt: ModernMilitaryTacticsMt.
isa: PlanActionRestrictionPredicate BinaryConstant IKBConstant.
arg1Isa: MilitaryTask.
arg2Isa: Distance.
comment: "".

F:
(implies
  (and
   (depthConstraintOfTask ?TASK ?DEPTH)
   (unitAssignedToTask ?UNIT ?TASK)
   (objectActedOn ?TASK ?OPPUNIT)
   (isa ?OPPUNIT ModernMilitaryUnit-Deployable)
   (hasAttributes ?OPPUNIT HostileUnit))
  (preconditionFor-PropSit
    (distanceBetween ?UNIT ?OPPUNIT ?DEPTH) ?TASK)).

constant: traversalConstraintOfTask.
in Mt: ModernMilitaryTacticsMt.
isa: PlanActionRestrictionPredicate.
arg1Isa: MilitaryTask.
arg2Isa: Distance.
comment: "(#$traversalConstraintOfTask TASK DISTANCE) means that any
unit assigned to TASK will be required to traverse a distance of at
least DISTANCE along the #$AxisOfAdvance, in executing TASK.".

F:
(implies
  (and
   (traversalConstraintOfTask ?TASK ?DISTANCE)
   (axisOfAdvanceForTask ?TASK ?AXIS))
  (preconditionFor-PropSit
    (greaterThanOrEqualTo (lengthOfObject 